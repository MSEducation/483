[[Binary translation]]

CATEGORIES: Emulation software, Interpreters (computing), Virtualization software

In computing, binary translation (or (binary) recompilation) is the emulation of one instruction set by another through translation of binary code. Sequences of instructions are translated from the source to the target instruction set. In some cases such as instruction set simulation, the target instruction set may be the same as the source instruction set, providing testing and debugging features such as instruction trace, conditional breakpoints and hot spot detection.
The two main types are static and dynamic binary translation.  Translation can be done in hardware (for example, by circuits in a CPU) or in software (e.g. run-time engines, statical recompiler, emulators).

==Motivation==

Motivation for using the complex process of binary translation is either that a compilation of the source code to the destination platform or instruction set is not available (or technical problematic) or when the source code is plainly not available anymore (Abandonware).
Performance wise static recompilations have the potential to achieve a better performance than real emulation approaches as in optimal case one overhead introducing interface is removed.

==Static binary translation==

A translator using static binary translation aims to convert all of the code of an executable file into code that runs on the target architecture without having to run the code first, as is done in dynamic binary translation. This is very difficult to do correctly, since not all the code can be discovered by the translator. For example, some parts of the executable may be reachable only through indirect branches, whose value is known only at run-time.
One such static binary translator uses universal superoptimizer peephole technology (developed by Sorav Bansal, and Alex Aiken from Stanford University) to perform efficient translation between possibly many source and target pairs, with considerably low development costs and high performance of the target binary. In experiments of PowerPC-to-x86 translations, some binaries even outperformed native versions, but on average they ran at two-thirds of native speed.

===Examples for static binary translations===

In 2014 a ARM architecture version of the 1998 video game Starcraft was generated by static recompilation and additional reverse engineering of the original x86 version.[tpl]cite web|url=http://www.golem.de/news/open-pandora-starcraft-fuer-arm-handheld-kompiliert-1403-105031.html |title=Starcraft für ARM-Handheld kompiliert |date=March 10, 2014|first=Peter |last=Steinlechner |accessdate=March 25, 2014| language=german |publisher=golem.de[/tpl][tpl]cite web|url=http://repo.openpandora.org/?page=detail&app=package.starcraft |title=StarCraft |author=notaz |date=March 4, 2014 |accessdate=March 26, 2014|publisher=repo.openpandora.org[/tpl]
The Pandora handheld community was capable of developing the required tools on their own and achieving such translations successfully several times.[tpl]cite web|url=http://boards.openpandora.org/topic/15820-starcraft/|quote=The "no source, no port" rule is not completely true, you can get something similar (but not the same) as a port through static recompilation. Similar stuff was done several times by M-HT for some DOS games. The game was also converted for Android with somewhat similar approach.|title=Starcraft|author=notaz|date=March 4, 2014|accessdate=March 29, 2014|publisher=openpandora.org[/tpl][tpl]cite web |url=http://repo.openpandora.org/?page=detail&app=warcraft_sr |title=Warcraft: Orcs & Humans |publisher=repo.openpandora.org[/tpl]

==Dynamic binary translation==

Dynamic binary translation looks at a short sequence of code—typically on the order of a single basic block—then translates it and caches the resulting sequence. Code is only translated as it is discovered and when possible, and branch instructions are made to point to already translated and saved code (memoization).
Dynamic binary translation differs from simple emulation (eliminating the emulator's main read-decode-execute loop—a major performance bottleneck), paying for this by large overhead during translation time. This overhead is hopefully amortized as translated code sequences are executed multiple times.
More advanced dynamic translators employ dynamic recompilation where the translated code is instrumented to find out what portions are executed a large number of times, and these portions are optimized aggressively. This technique is reminiscent of a JIT compiler, and in fact such compilers (e.g. Sun's HotSpot technology) can be viewed as dynamic translators from a virtual instruction set (the bytecode) to a real one.

===Examples for dynamic binary translations in software===

===Examples for dynamic binary translations in hardware===

==See also==

==References==

==Further reading==


