[[Hylomorphism (computer science)]]

CATEGORIES: Articles with example Haskell code, Category theory, Recursion schemes

In computer science, and in particular functional programming, a hylomorphism is a recursive function, corresponding to the composition of an anamorphism (which first builds a set of results; also known as 'unfolding') and a catamorphism (which then folds these results into a final return value). Fusion of these two recursive computations into a single recursive pattern then avoids building the intermediate data structure. This is a particular form of the optimizing program transformation techniques collectively known as deforestation. A related type of function is a metamorphism, which is a catamorphism followed by an anamorphism.

==Formal definition==

Thus a hylomorphism

===Notation===

==Hylomorphisms in practice==

===Lists===

Lists are common data structures as they naturally reflect linear computational processes.  These processes arise in repeated (iterative) function calls.  Therefore it is sometimes necessary to generate a temporary list of intermediate results before reducing this list to a single result.
One example of a commonly encountered hylomorphism is the canonical factorial function.
In the previous example (written in Haskell, a purely functional programming language) it can be seen that this function, applied to any given valid input, will generate a linear call tree isomorphic to a list. For example, given n = 5 it will produce the following:
 factorial 5 = 5 * (factorial 4) = 120
 factorial 4 = 4 * (factorial 3) = 24
 factorial 3 = 3 * (factorial 2) = 6
 factorial 2 = 2 * (factorial 1) = 2
 factorial 1 = 1 * (factorial 0) = 1
 factorial 0 = 1

===Trees===

However, the term 'hylomorphism' does not apply solely to functions acting upon isomorphisms of lists. For example, a hylomorphism may also be defined by generating a non-linear call tree which is then collapsed. An example of such a function is the function to generate the nth term of the Fibonacci sequence.
This function, again applied to any valid input, will generate a call tree which is non-linear. In the example on the right, the call tree generated by applying the fibonacci function to the input 4.
This time, the anamorphism is the generation of the call tree isomorphic to the tree with leaf nodes 0, 1, 1, 0, 1 and the catamorphism the summation of these leaf nodes.

==See also==

==References==

|url=http://citeseer.ist.psu.edu/cachedpage/214108/1
|title=Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire
|author=Erik Meijer, Maarten Fokkinga, Ross Paterson
|pages=4, 5
|year=1991
}}

==External links==


