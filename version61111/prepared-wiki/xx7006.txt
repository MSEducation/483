[[Linker (computing)]]

CATEGORIES: Compilers, Computer libraries, Programming language implementation, Utility software types

In computer science, a linker or link editor is a computer program that takes one or more object files generated by a compiler and combines them into a single executable program.
A simpler version that wrote its output directly to memory was called the loader, though loading is typically considered a separate process.[tpl]cite book|last=IBM Corporation|title=IBM OS Linkage Editor and Loader|year=1972|url=http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/360/os/R21.0_Mar72/GC28-6538-9_OS_Linkage_Editor_and_Loader_Release_21_Jan72.pdf[/tpl]

==Overview==

Computer programs typically comprise several parts or modules; these parts/modules need not all be contained within a single object file, and in such case refer to each other by means of symbols.  Typically, an object file can contain three kinds of symbols:
For most compilers, each object file is the result of compiling one input source code file. When a program comprises multiple object files, the linker combines these files into a unified executable program, resolving the symbols as it goes along.
Linkers can take objects from a collection called a library. Some linkers do not include the whole library in the output; they only include its symbols that are referenced from other object files or libraries. Libraries exist for diverse purposes, and one or more system libraries are usually linked in by default.
The linker also takes care of arranging the objects in a program's address space. This may involve relocating code that assumes a specific base address to another base. Since a compiler seldom knows where an object will reside, it often assumes a fixed base location (for example, zero). Relocating machine code may involve re-targeting of absolute jumps, loads and stores.
The executable output by the linker may need another relocation pass when it is finally loaded into memory (just before execution). This pass is usually omitted on hardware offering virtual memory: every program is put into its own address space, so there is no conflict even if all programs load at the same base address. This pass may also be omitted if the executable is a position independent executable.
On some Unix variants, such as SINTRANÂ III, the process performed by a linker (assembling object files into a program) was called loading (as in loading executable code onto a file).BRF-LINKER User Manual. ND-60.196.01. 08/84. Additionally, in some operating systems the same program handles both the jobs of linking and loading a program (dynamic linking).

==Dynamic linking==

Many operating system environments allow dynamic linking, that is the postponing of the resolving of some undefined symbols until a program is run. That means that the executable code still contains undefined symbols, plus a list of objects or libraries that will provide definitions for these. Loading the program will load these objects/libraries as well, and perform a final linking. Dynamic linking needs no linker.
This approach offers two advantages:
There are also disadvantages:

==[tpl]Anchor|RELAXATION[/tpl]Relaxation==

As the compiler has no information on the layout of objects in the final output, it cannot take advantage of shorter or more efficient instructions that place a requirement on the address of another object. For example, a jump instruction can reference an absolute address or an offset from the current location, and the offset could be expressed with different lengths depending on the distance to the target. By generating the most conservative instruction (usually the largest relative or absolute variant, depending on platform) and adding relaxation hints, it is possible to substitute shorter or more efficient instructions during the final link. This step can be performed only after all input objects have been read and assigned temporary addresses; the linker relaxation pass subsequently re-assigns addresses, which may in turn allow more relaxations to occur. In general, the substituted sequences are shorter, which allows this process to always converge on the best solution given a fixed order of objects; if this is not the case, relaxations can conflict, and the linker needs to weigh the advantages of either option.
While instruction relaxation typically occurs at link-time, inner-module relaxation can already take place as part of the optimization process at compile-time. In some cases, relaxation can also occur at load-time as part of the relocation process or combined with dynamic dead-code elimination techniques.

==Linkage editor==

In IBM mainframe environments such as OS/360 this type of program is known as a linkage editor. However, a linkage editor, as the name implies, had the additional capability of allowing the addition, replacement, and/or deletion of individual program sections. Operating systems such as OS/360 had a different format for executable load-modules, in that they contained supplementary data about the component sections of a program, so that an individual program section could be replaced, and other parts of the program updated so that relocatable addresses and other such references could be corrected by the linkage editor, as part of the process.
One advantage of this is that it would allow a program to be maintained without having to keep all of the intermediate object files, or without having to re-compile program sections that hadn't changed. It also permitted program updates to be distributed in the form of small card decks, containing only the object module to be replaced. In such systems, object code was in the form and format of punched-card decks, so that updates could be introduced into a system using that medium. In later releases of OS/360 and in subsequent systems, load-modules contained additional data about versions of components modules, to create a traceable record of updates.
Note: the term "linkage editor" should not be construed as implying that the program operated in a user-interactive mode (like, for example, a text editor). It was strictly intended for batch-mode execution.

==See also==

==Notes==

==References==

==External links==


