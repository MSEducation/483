[[Filename extension]]

CATEGORIES: Computer file formats, Metadata, Files, Names, Filename extensions

A filename extension is a suffix (separated from the base filename by a dot or space) to the name of a computer file applied to indicate the encoding (file format) of its contents or usage. Examples of filename extensions are .jpeg, .dmg and .
Some file systems limit the length of the extension (such as the FAT file system from PC DOS/MS-DOS (without Long filename support) not allowing more than three characters and IBM's VM/CMS not allowing more than 8) while others (such as NTFS) do not. Unix filesystems accept the separator dot as a legal character.

Usage

Filename extensions can be considered a type of metadata. They are commonly used to imply information about the way data might be stored in the file. The exact definition, giving the criteria for deciding what part of the file name is its extension, belongs to the rules of the specific filesystem used; usually the extension is the substring which follows the last occurrence, if any, of the dot character (example: txt is the extension of the filename readme.index.
On file systems of mainframe systems such as MVS, VMS, and PC systems such as CP/M and derivative systems such as MS-DOS, the extension is a separate namespace from the filename. Under Microsoft's DOS and Windows, extensions such as EXE, COM or BAT indicate that a file is a program executable.
The UNIX-like filesystems use a different model without the segregated extension metadata. The dot character is just another character in the main filename, and filenames can have multiple extensions, usually representing nested transformations, such as files.gz. Programs transforming or creating files may add the appropriate extension to names inferred from input file names (unless explicitly given an output file name), but programs reading files mostly ignore the information; it is foremost intended for the human user. This model generally requires the full filename to be provided in commands, where the metadata approach often allows the extension to be omitted.
With the advent of graphical user interfaces, the issue of file management and interface behavior arose. Microsoft Windows allowed multiple applications to be associated with a given extension, and different actions were available for selecting the required application, such as a context menu offering a choice between viewing, editing or printing the file. The assumption was still that any extension represented a single file type; there was an unambiguous mapping between extension and icon.
Pre-OS X versions of the Mac OS disposed of filename-based extension metadata entirely, instead using a distinct file type code to identify the file format. Additionally, a creator code was specified to determine which application would be launched when the file's icon was double-clicked. Mac OS X, however, uses filename suffixes, as well as type and creator codes, as a consequence of being derived from the UNIX-like NeXTSTEP operating system.

Improvements

The filename extension was originally used to easily determine the file's generic type. The need to condense a file's type into three characters frequently led to inscrutable extensions. Examples include using .TXT for plain text, and . However, because many different software programs have been made that all handle these data types (and others) in a variety of ways, filename extensions started to become closely associated with certain products—even specific product versions.  For example, early WordStar files used .WSn, where n was the program's version number.  Also, filename extensions began to conflict between separate files.  One example is .RPM Details from filext.qif, shared by DESQview fonts, Quicken financial ledgers, and QuickTime pictures,File Extension .com and .File Extension .GBA Details
Some other operating systems such as Multics that used filename extensions generally had much more liberal sizes for filenames.  Many allowed full filename lengths of 14 or more characters, and maximum name lengths up to 255 were not uncommon.  The file systems in operating systems such as UNIX stored the file name as a single string, not split into base name and extension components, with the "." being just another character allowed in file names.  Such systems generally allow for variable-length filenames, permitting more than one dot, and hence multiple suffixes.  Some components of Multics and UNIX, and applications running on them, used suffixes, in some cases, to indicate file types, but they did not use them as much—for example, executables and ordinary text files had no suffixes in their names.
The High Performance File System (HPFS), used in Microsoft and IBM's OS/2 also supported long file names, and did not divide the file name into a name and an extension.  The convention of using suffixes continued, even though HPFS supported extended attributes for files, allowing a file's type to be stored with the file as an extended attribute.
Microsoft's Windows NT's native file system, NTFS, supported long file names and did not divide the file name into a name and an extension, but again, the convention of using suffixes to simulate extensions continued, for compatibility with existing versions of Windows.
When the Internet age first arrived, those using Windows systems that were still restricted to 8.3 filename formats had to create web pages with names ending in .html filename extension. This also became a problem for programmers experimenting with the Java programming language, since it requires source code files to have the four-letter suffix .class suffix.
Eventually, Windows introduced support for long file names, and removed the 8.3 name/extension split in file names, in an extended version of the commonly used FAT file system called VFAT.  VFAT first appeared in Windows NT 3.5 and Windows 95.  The internal implementation of long file names in VFAT is largely considered to be a kludge, but it removed the important length restriction, and allowed files to have a mix of upper case and lower case letters, on machines that would not run Windows NT well. However, the use of three-character extensions under Microsoft Windows has continued, originally for backward compatibility with older versions of Windows and now by habit, along with the problems it creates.

Command name issues

The use of a filename extension in a command name appears occasionally, usually as a side effect of the command having been implemented as a script (in Bourne shell, Python, etc.) and the interpreter name being  suffixed to the command name, a practice common on systems like Windows and Mac OS X, which rely on globally set associations between filename extension and interpreter, but sharply deprecatedCommandname Extensions Considered Harmful in UNIX-derived systems like Linux and Apple's Mac OS X, where the interpreter is normally specified as a header in the script ("shebang").
On association-based systems, the filename extension is generally mapped to a single, system-wide selection of interpreter for that extension (such as ".  If the implementation language is changed, the command name extension is changed as well, and the OS provides a consistent API by allowing the same extension-less version of the command to be used in both cases.  This method suffers somewhat from the essentially global nature of the association mapping, as well as from developers' incomplete avoidance of extensions when calling programs, and that developers can't force that avoidance.  Windows is the only remaining widespread employer of this mechanism.
On systems with interpreter directives, command name extensions have no special significance, and are by standard practice not used, since the primary method to set interpreters for scripts is to start them with a single line specifying the interpreter to use (which could be viewed as a degenerate resource fork).

Security issues

The default behavior of Windows Explorer, the file browser provided with Microsoft Windows, is for filename extensions to not be displayed. Malicious users have tried to spread  computer viruses and  computer worms by using file names formed like LOVE-LETTER-FOR-YOU.vbs. The hope is that this will appear as LOVE-LETTER-FOR-YOU.
Later Windows versions (starting with Windows XP Service Pack 2 and Windows Server 2003) included customizable lists of filename extensions that should be considered "dangerous" in certain "zones" of operation, such as when downloaded from the web or received as an e-mail attachment. Modern antivirus software systems also help to defend users against such attempted attacks where possible.
Some viruses take advantage of the similarity between the ".COM" file extension by emailing malicious, executable command-file attachments under names superficially similar to URLs (e.g., "myparty.com"), with the effect that some naive users click on email-embedded links that they think lead to websites but actually download and execute the malicious attachments.
There have been instances of malware crafted to exploit vulnerabilities in some Windows applications which could cause a stack-based buffer overflow when opening a file with an overly long, unhandled filename extension.

Alternatives

In  network contexts, files are regarded as streams of bits and do not have filenames or extensions.
In many internet protocols such as HTTP and MIME email, the type of a bitstream is stated as the internet media type of the stream (also called the MIME type or content type). This is given in a line of text preceding the stream, such as:
Content-type: text/plain
Because there is no standard mapping between filename extensions and internet media types, mismatches in file type interpretation between authors, web servers, and client software can be a source of errors when transferring files over the internet. For instance, a content author may specify a .
BeOS, whose BFS file system supports extended attributes, would tag a file with its internet media type as an extended attribute.  The KDE and GNOME desktop environments associate an internet media type with a file by examining both the filename suffix and the contents of the file, in the fashion of the file command, as a heuristic.  They choose the application to launch when a file is opened based on that internet media type, reducing the dependency on filename extensions. Mac OS X uses both filename extensions and media types, as well as file type codes, to select a Uniform Type Identifier by which to identify the file type internally.








